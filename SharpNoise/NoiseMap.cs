using System.Threading.Tasks;
namespace SharpNoise
{
    /// <summary>
    /// Implements a noise map, a 2-dimensional array of floating-point
    /// values.
    /// </summary>
    /// <remarks>
    /// A noise map is designed to store coherent-noise values generated by a
    /// noise module, although it can store values from any source.  A noise
    /// map is often used as a terrain height map or a grayscale texture.
    ///
    /// The size (width and height) of the noise map can be specified during
    /// object construction or at any other time.
    /// 
    /// All of the values outside of the noise map are assumed to have a
    /// common value known as the border value.
    ///
    /// To set the border value, modify the BorderValue property.
    /// </remarks>
    public class NoiseMap : Map<float>
    {
        public override int UsedMemory
        {
            get
            {
                return values.Length * sizeof(float);
            }
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        public NoiseMap() { }

        /// <summary>
        /// Constructor.
        /// </summary>
        public NoiseMap(int width, int height)
            : base(width, height)
        {

        }

        /// <summary>
        /// Constructor.
        /// </summary>
        public NoiseMap(NoiseMap other)
            : base(other)
        {

        }

        /// <summary>
        /// Create a new NoiseMap from the given source NoiseMap using bilinear filtering.
        /// 
        /// When the sample is outside the source BorderValue is used by default. If <see cref="clamp"/>/>
        /// is set clamping is used instead.
        /// </summary>
        /// <param name="src">The source NoiseMap</param>
        /// <param name="width">Width of the new NoiseMap</param>
        /// <param name="height">Height of the new NoiseMap</param>
        /// <param name="clamp">Use clamping when the sample is outside the source NoiseMap</param>
        /// <returns>The new NoiseMap</returns>
        public static NoiseMap BilinearFilter(NoiseMap src, int width, int height, bool clamp = false)
        {
            var dest = new NoiseMap(width, height);

            float xratio = (float)src.Width / dest.Width;
            float yratio = (float)src.Height / dest.Height;

            Parallel.For(0, dest.Height, y =>
            {
                for (int x = 0; x < dest.Width; ++x)
                {
                    float u = (x + 0.5f) * xratio - 0.5f;
                    float v = (y + 0.5f) * yratio - 0.5f;

                    int x0 = NoiseMath.FastFloor(u);
                    int y0 = NoiseMath.FastFloor(v);
                    int x1 = x0 + 1;
                    int y1 = y0 + 1;

                    float xf = u - x0;
                    float yf = v - y0;

                    if (clamp)
                    {
                        x0 = NoiseMath.Clamp(x0, 0, src.Width - 1);
                        x1 = NoiseMath.Clamp(x1, 0, src.Width - 1);
                        y0 = NoiseMath.Clamp(y0, 0, src.Height - 1);
                        y1 = NoiseMath.Clamp(y1, 0, src.Height - 1);
                    }

                    float c00 = src.GetValue(x0, y0);
                    float c01 = src.GetValue(x0, y1);
                    float c10 = src.GetValue(x1, y0);
                    float c11 = src.GetValue(x1, y1);

                    float val = NoiseMath.Bilinear(xf, yf, c00, c01, c10, c11);

                    dest.SetValue(x, y, val);
                }
            });

            return dest;
        }
    }
}
